---
title: JVM体系结构(一)
subTitle: jvm整理
category: java
cover: java.png
---

**前言**

​    Java语言的一个非常重要的特点就是与平台的无关性。而使用Java虚拟机是实现这一特点的关键。

​    一般的高级语言如果要在不同的平台上运行，至少需要编译成不同的目标代码。而引入Java语言虚拟机后，Java语言在不同平台上运行时不需要重新编译。

​    Java语言使用Java虚拟机屏蔽了与具体平台相关的信息，使得Java语言编译程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。

​    Java虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。这就是Java的能够“一次编译，到处运行”的原因.

   

**JRE/JDK/JVM是什么关系**

​    *JRE*(JavaRuntimeEnvironment，Java运行环境)，也就是Java平台。所有的Java 程序都要在JRE下才能运行。普通用户只需要运行已开发好的java程序，安装JRE即可。



​    *JDK*(Java Development Kit)是程序开发者用来来编译、调试java程序用的开发工具包。JDK的工具也是Java程序，也需要JRE才能运行。

​    为了保持JDK的独立性和完整性，在JDK的安装过程中，JRE也是 安装的一部分。所以，在JDK的安装目录下有一个名为jre的目录，用于存放JRE文件。



​    *JVM*(JavaVirtualMachine，Java虚拟机)是JRE的一部分。它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。

​    JVM有自己完善的硬件架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。

​    Java语言最重要的特点就是跨平台运行。使用JVM就是为了支持与操作系统无关，实现跨平台。

​    

![img](/jdk.jpeg)

​    

**JVM体系结构**



![img](/jvm.png)

*类装载器*（ClassLoader）（用来装载.class文件）



*执行引擎*（执行字节码，或者执行本地方法）



*运行时数据区*（方法区、堆、java栈、PC寄存器、本地方法栈）



*Java堆*（Heap）,是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。



*方法区*（Method Area）,方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。



*程序计数器*（Program Counter Register）,程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。



*JVM栈*（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。



*本地方法栈*（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。



**JVM选择基于栈的架构的原因**

  JVM执行字节码指令是基于栈的架构的，所有的操作数必须先入栈，然后根据指令的操作码选择从栈顶弹出若干个元素进行计算后再将结果入栈。JVM操作数可以存放在每一个栈帧中的一个本地变量中，即每个方法调用时就会给这个方法分配一个本地变量集，这个本地变量集在编译时就已经确定，所以操作数入栈可以直接是常量或者从本地变量集中娶一个变量压入栈中。   JVM基于栈的设计理由是   (1)JVM要设计成与平台无关的，而平台无关性就要保证在没有或者由很少的寄存器的机器上也能同样正确执行java代码，因为寄存器很难做到通用。   (2)基于栈的理由是为JVM更好地优化代码而设计的   (3)为了指令的紧凑性，因为java代码可能在网络上传输，所以class文件的大小也是设计JVM字节码指令的一个重要因素。





详细模型 参见JVM内存区域(三)



![img](/jvm-1.png)



![img](/jvm-2.png)



（1）线程私有区：

程序计数器，记录正在执行的虚拟机字节码的地址；

虚拟机栈：方法执行的内存区，每个方法执行时会在虚拟机栈中创建栈帧；

本地方法栈：虚拟机的Native方法执行的内存区；

（2）线程共享区：

Java堆：对象分配内存的区域；

方法区：存放类信息、常量、静态变量、编译器编译后的代码等数据；

常量池：存放编译器生成的各种字面量和符号引用，是方法区的一部分。



*注意 :对于大多数的程序员来说，Java内存比较流行的说法便是堆和栈，这其实是非常粗略的一种划分，这种划分的”堆”对应内存模型的Java堆，”栈”是指虚拟机栈*



**栈帧(Stack Frame)结构**

栈帧是用于支持虚拟机进行方法执行的数据结构，是属性运行时数据区的虚拟机站的栈元素。见上图， 栈帧包括：

局部变量表  (locals大小，编译期确定)，一组变量存储空间， 容量以slot为最小单位。

操作栈  (stack大小，编译期确定)，操作栈元素的数据类型必须与字节码指令序列严格匹配

动态连接， 指向运行时常量池中该栈帧所属方法的引用，为了 动态连接使用。

- - - 前面的解析过程其实是静态解析；
    - 对于运行期转化为直接引用，称为动态解析。

方法返回地址

正常退出，执行引擎遇到方法返回的字节码，将返回值传递给调用者

异常退出，遇到Exception,并且方法未捕捉异常，那么不会有任何返回值。

额外附加信息，虚拟机规范没有明确规定，由具体虚拟机实现。



